/** @module recline */

var fs = require('fs'),
    path = require('path'),
		url = require("url"),
		http = require("http"),
		couchdb = require('./vendor/couchdb'),
		utils = require("underscore");
		
var modules = [];

exports.setBasePath = function(dirname) {
	this.dirname = exports.parsePathForTrailingSlash(dirname);
}

exports.set_prefix = function(pf){
	this.prefix = pf + "-";
}

exports.get_prefix = function(){
	return this.prefix;
}

exports.setTempDir = function(relativeDirPathToReclineBase) {
	var $ = exports.parsePathForTrailingSlash(relativeDirPathToReclineBase);
	this.tempDir = this.dirname ? this.dirname + $ : __dirname + $;
}
 
exports.parsePathForTrailingSlash = function(path) {
	var $ = path;
	if($.lastIndexOf("/")+1 != $.length){
		$ = $ + "/";
	}
	return $;
}

exports.settings = function(dir,settings){
	var self = this;
	
	// Sets project base path
	self.setBasePath(dir);
	settings = dir + settings;

	if(typeof process.env.NODE_ENV === "undefined"){
		var environment = "development";
	}else
	{
		var environment = process.env.NODE_ENV;
	}
	
	var data = fs.readFileSync(settings, 'utf8');
	var json = JSON.parse(data);
	self.conf = json[environment];

	if(!self.conf.couchdbConnectionString){
		throw new Error("no connection string");
	}

	if(!self.conf.dbPrefix){
		throw new Error("no db prefix");
	}

	if(!self.conf.tempDir){
		console.warn("WARNING: no tempDir set, defaulting to "+__dirname+"/tmp");
	}
	
	self.set_prefix(self.conf.dbPrefix);
	self.addModelDir(self.conf.modelDir);
	self.addViewDir(self.conf.viewDir);
	self.setTempDir(self.conf.tempDir);
	self.setup(self.conf.couchdbConnectionString);
	
	return self;



}

exports.setup = function(u) {
	
	if(typeof this.tempDir === "undefined") {
		this.setTempDir("tmp/");
	}
	
	this.databases = {};
	if(typeof this.uri === "object") {
		this.callback && this.callback();
		
	}
	
	if(typeof u === "string") {			
		var uri = url.parse(u);
		if(!uri.protocol) {
			throw new Error("must be http protocol");
		}else
		{	
			this.uri = uri;
		}
		
		utils.extend(this.uri, this._auth(this.uri.auth), { prefix: this.get_prefix()});
		console.info("INFO: setup complete. moving to add modules");
		this.initialiseCore();
		//this.initialiseModules();
		
	}else{
		throw new Error("setup requires connection string");
	}
	
}

exports.initialiseCore = function(){
	var self = this;
	fs.readdir(__dirname + "/core", function(err,files){
		var l = files.length;
		for(var i=0; i<l;i++){
			var file = files[i];
			file = file.split(".")[0];
			self[file] = require("./core/" + file);
		}
		self.initialiseModules();
	});
	
}



exports.initialiseModules = function(){
	
	var self = this;
	
	if(this.conf.installedModules){
		
		self.modules = this.conf.installedModules;
		self.moduleLength = self.modules.length;

		for(var i=0; i<self.moduleLength; i++ ){
			if(typeof self.modules[i] == "string"){
				var a = self.modules[i].split(".");
				if(a.length>1){
					// Handle module sub modules
				}else{
					var db = a[0];			
					
					this.createdb(db, function(er, ok){
						
						self.checkDatabaseConnections();
					});
				}
			}else{
				throw new Error("cannot initialise modules");
			}
		}
		
		self.callback && self.callback();
	}
	

}

exports.checkDatabaseConnections = function(){
	var self = this;
	if(self.moduleLength == utils.size(self.databases)){
	var det = function(item){ return item == key; }; 
		for(var key in self.databases){
			if(!utils.detect(self.modules,det)){
				throw new Error("cannot initialise modules")
			}
		}
	}
}

exports.createdb = function(name, fn){
	// I need to makesure that this is cached everytime that a database is created
	// it should store it for later use - possibly cradle cache funtion?
	var o = utils.clone(this.uri);
	var self = this;
	if(typeof this[name] === "object"){
		if(typeof this[name].db == "object"){
			return this[name];
		}
	}

	var auth = o.auth.split(":");
	auth = { user : auth[0], pass: auth[1] };
	self._client = new couchdb.createClient(o.port, o.hostname, auth.user, auth.pass);
	
	this[name] = self._client.db(this.uri.prefix + name);
	this.databases[name] = this[name];
	
	var db = this[name];
	
	this[name].exists(function(err,ok){
		
		if(ok){
			if(typeof fn === "function"){
				fn.call(this, null,db);
			}
		}else{
			
			self._client.request('PUT', '/'+self.uri.prefix + name);
			fn.call(this, null,db);
		}
		
		
	});
	
}

exports.destroyAll = function(fn) {
	for(var key in this.databases){
		this.databases[key].remove();
	}
}
// TODO: These two methods are duplcates, we need to combine these methods into one
exports.addModelDir = function(relativeDirPathToReclineBase){
     var exists = path.existsSync(this.dirname + relativeDirPathToReclineBase);
	if(exists){
	  var $ = exports.parsePathForTrailingSlash(relativeDirPathToReclineBase);
	  this.modelDir = this.dirname ? this.dirname + $ : __dirname + $;
	}else{
	  this.modelDir = __dirname;
	}	
}

exports.addViewDir = function(relativeDirPathToReclineBase){
     var exists = path.existsSync(this.dirname + relativeDirPathToReclineBase);
	if(exists){
	  var $ = exports.parsePathForTrailingSlash(relativeDirPathToReclineBase);
	  this.viewDir = this.dirname ? this.dirname + $ : __dirname + $;
	}else{
	  this.viewDir = __dirname;
	}	
}

exports._auth = function(auth) {
  return { "basic" : "Basic " + new Buffer(auth).toString('base64') }
}

exports.parseArgs = function(req){
	var a = [];
	if(typeof req.params === "object"){
		
		for(var key in req.params){
			a.push(req.params[key]);
		}
	}
	
	if(typeof req.body === "object"){
		a.push(req.body);
	}
	
	return a;
	
}

exports.moduleExists = function(name,type) {
	var self = this;
	switch(type){
		case 'model':
			return path.existsSync(self.modelDir+name+".js");
		case 'view':
			return path.existsSync(self.viewDir+name+".js");
		default:
			return path.existsSync(self.modelDir+name);
	}

}

exports.module = function(name) {
	var self = this;
	
	if(self.moduleExists(name)){
		return require(self.modelDir+name);
	}else{
		return require('./'+name);
	}
}

exports.response = function(module, method, view){
	var self = this;
	if(!view){
		return function(req,res,next){
			
			args = self.parseArgs(req);
			var cb = function(er,data){
				if(next.name != ""){
					if(er) next(er);
					utils.extend(res, { data: data,
					       	            render: utils.bind(res,self._tmpl.render) });
					next();
				}else{	
					 res.send(data);
				}
			}
			args.push(cb);
			module[method].apply(module, args);
		
		};
	}else{
		return function(req,res){
			module[method](req,res);
		}
	}	

}

exports.model = function(name, method) {
	var self = this;
	
	if(self.moduleExists(name,'model')){
		return self.response(require(self.modelDir+name), method);
	}else{
		return self.response(require('./models/'+name), method);
	}
	
}

exports.view = function(name,method) {
	var self = this;
	if(self.moduleExists(name, 'view')){
		return self.response(require(self.viewDir+name), method, true);
	}else{
		return self.response(require('./views/'+name), method, true);
	}
}	



